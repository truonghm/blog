[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Truong Hoang",
    "section": "",
    "text": "Transitioning from pip to uv\n\n\n\n\n\n\npython\n\n\ncode\n\n\ntricks\n\n\n\n\n\n\n\n\n\nJan 20, 2025\n\n\nTruong Hoang\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Welcome to my blog."
  },
  {
    "objectID": "posts/pip-uv-transition/index.html",
    "href": "posts/pip-uv-transition/index.html",
    "title": "Transitioning from pip to uv",
    "section": "",
    "text": "In this post, I will share my experience with transitioning from pip / older uv APIs to the new uv APIs.\n\nIntroduction\nuv is the new kid on the Python package manager block and it’s been making waves. It’s self-described as “an extremely fast Python package and project manager, written in Rust”. The benchmark results are impressive:\n\n\n\n\n\nI started incorporating uv into the workflow of my Python projects back in early 2024, when it was still version 0.2.x. Back then, uv adopted the pip-tools API and aimed to be a drop-in replacement for pip-tools, which was actually what we were using at the time. The transition was smooth and we didn’t have to change much in our workflow. However, we were also aware of the various limitations of pip-tools, such as having to manage separate requirements.txt and requirements-dev.txt files, which sometimes led to inconsistencies between the two. Thankfully, recent versions of uv have added a new set of uv-native APIs that use a single lockfile in TOML format, which makes packaging and sharing dependencies much easier. In this post, I will share my experience with transitioning from pip / older uv APIs to the new uv APIs.\n\n\nMoving dependencies from requirements.txt to uv.lock\nThe first step in transitioning to the new uv APIs is to move your dependencies from requirements.txt to uv.lock. I want to keep the versions between the old requirements file and the new lockfile as similar as possible, while also making sure that both dev and non-dev dependencies are included in the lockfile. In order to achieve that, we first need to generate a new lockfile using the uv CLI.\nAssume that a pyproject.toml file exists in the current project, we can generate a new lockfile by running the following command:\nuv lock\nThis will generate a new lockfile in the current directory. This lockfile most probably will contain different versions of the same package, especially if the top-level packages in pyproject.toml are unconstrained (i.e. not pinned). To compare the versions between the old requirements file and the new lockfile, we can write a simple Python script that reads both files and compares the versions of the packages.\nFirst, let’s create a function to compare the versions:\nfrom pathlib import Path\n\nimport pandas as pd\n\n\ndef compare_version(lockfile: str, requirements: str) -&gt; pd.DataFrame:\n    lockfile_path = Path(lockfile)\n    requirements_path = Path(requirements)\n\n    if not lockfile_path.exists():\n        raise FileNotFoundError(f\"Lockfile {lockfile} not found\")\n\n    if not requirements_path.exists():\n        raise FileNotFoundError(f\"Requirements file {requirements} not found\")\n\n    lockfile_packages = []\n    with open(lockfile_path, \"r\") as f:\n        lines = f.readlines()\n        for i, line in enumerate(lines):\n            if line.strip().startswith(\"name = \"):\n                if i &gt; 0 and lines[i - 1].strip() == \"[[package]]\":\n                    if i &lt; len(lines) - 1 and lines[i + 1].strip().startswith(\"version = \"):\n                        name = line.split(\"=\")[1].strip().strip('\"')\n                        version = lines[i + 1].split(\"=\")[1].strip().strip('\"')\n                        lockfile_packages.append({\"name\": name, \"version\": version})\n\n    lockfile_df = pd.DataFrame(lockfile_packages)\n\n    requirements_packages = []\n    with open(requirements_path, \"r\") as f:\n        lines = f.readlines()\n        for line in lines:\n            if not line.strip().startswith(\"#\") and line.strip():\n                name, version = line.strip().split(\"==\")\n                requirements_packages.append({\"name\": name, \"version\": version})\n\n    requirements_df = pd.DataFrame(requirements_packages)\n\n    df = pd.merge(lockfile_df, requirements_df, on=\"name\", how=\"outer\", suffixes=(\"_lockfile\", \"_requirements\"))\n\n    return df\nAfter that, a need that may arise is to “sync” the versions from the old requirements file to the new lockfile on a best-effort basis. This can be done by writing another function:\n\ndef sync_to_lockfile(lockfile: str, df: pd.DataFrame) -&gt; None:\n    lockfile_path = Path(lockfile)\n\n    new_lockfile = []\n    with open(lockfile_path, \"r\") as f:\n        lines = f.readlines()\n        for i, line in enumerate(lines):\n            if i &lt; 2:\n                new_lockfile.append(line)\n            elif line.strip().startswith(\"version = \"):\n                if i &gt; 0 and lines[i - 2].strip() == \"[[package]]\":\n                    if lines[i - 1].strip().startswith(\"name = \"):\n                        name = lines[i - 1].split(\"=\")[1].strip().strip('\"')\n                        new_version = df.query(\"name == @name\")[\"version_requirements\"].values[0]\n                        if new_version is None or str(new_version) == \"nan\":\n                            new_lockfile.append(line)\n                        else:\n                            new_lockfile.append(f'version = \"{new_version}\"\\n')\n            else:\n                new_lockfile.append(line)\n\n    lockfile_path.rename(lockfile_path.parent / f\"{lockfile_path.stem}_old{lockfile_path.suffix}\")\n    print(f\"Old lockfile renamed to {lockfile_path.parent / f'{lockfile_path.stem}_old{lockfile_path.suffix}'}\")\n    with open(lockfile_path, \"w\") as f:\n        f.writelines(new_lockfile)\n        print(f\"New lockfile saved to {lockfile_path}\")\nFinally, we can put it all together:\nif __name__ == \"__main__\":\n    import argparse\n\n    parser = argparse.ArgumentParser(description=\"Compare two versions of a lockfile and requirements file\")\n    parser.add_argument(\"--lockfile\", help=\"Path to the lockfile\")\n    parser.add_argument(\"--requirements\", help=\"Path to the requirements file\")\n    parser.add_argument(\n        \"--sync-to-lockfile\",\n        action=argparse.BooleanOptionalAction,\n        default=False,\n        help=\"Sync all versions from the requirements file to the lockfile\",\n    )\n    args = parser.parse_args()\n\n    df = compare_version(args.lockfile, args.requirements)\n    diff = df.query(\"version_lockfile != version_requirements\")\n    print(diff)\n    diff.to_csv(\"package_diff.csv\", index=False)\n\n    if args.sync_to_lockfile:\n        sync_to_lockfile(args.lockfile, df)\nThis script can be run with uv, however we need to add a little section at the top of the script to specify pandas as a script-level dependency:\n# /// script\n# requires-python = \"&gt;=3.10\"\n# dependencies = [\n#     \"pandas\",\n# ]\n# ///\nThen running the script is trivial:\n`uv run --python=3.10 --no-project scripts/compare_version.py --lockfile=./uv.lock --requirements=./requirements-dev.txt` \nThis script will compare the versions between the old requirements file and the new lockfile, and save the differences to a CSV file. If the --sync-to-lockfile flag is set, it will also sync the versions from the old requirements file to the new lockfile.\nTo summarise, the workflow would be:\n\nGenerate a new lockfile using uv lock\nRun the script the first time to review the differences\nuv run --python=3.10 --no-project scripts/compare_version.py --lockfile=./uv.lock --requirements=./requirements-dev.txt\nRun the script again, this time with the --sync-to-lockfile flag set to sync the versions from the old requirements file to the new lockfile\nuv run --python=3.10 --no-project scripts/compare_version.py --lockfile=./uv.lock --requirements=./requirements-dev.txt --sync-to-lockfile\nReview the changes in the lockfile and run uv sync to both install the dependencies add see if uv detects any issues or conflicts.\n\nFor example, one of my projects generated the following output (project-name is a project I’m working on):\n                   name version_lockfile version_requirements\n6               appnope            0.1.4                  NaN\n18   clickhouse-connect           0.8.14                  NaN\n19    clickhouse-driver            0.2.9                  NaN\n20             colorama            0.4.6                  NaN\n59                  lz4            4.3.3                  NaN\n108             pywin32              308                  NaN\n109        project-name            0.0.1                  NaN\n159             tzlocal              5.2                  NaN\n168           zstandard           0.23.0                  NaN\nThe entire script is available here. Feel free to use it or provide feedback on how to improve it.\n\n\nUpdating your Dockerfile\nIf you are using Docker to build your project, you will need to update your Dockerfile to use uv instead of pip to make full use of the new lockfile. There have been multiple examples of this (uv also provies an official guide in their docs), but I’ve found that this article by Hynek Schlawack works best for me. For a quick reference, here is an example of a Dockerfile that uses uv:\nFROM python:3.10 as build\nCOPY --from=ghcr.io/astral-sh/uv:0.4.22 /uv /bin/uv\n\nENV UV_LINK_MODE=copy \\\n    UV_COMPILE_BYTECODE=1 \\\n    UV_PYTHON_DOWNLOADS=never \\\n    UV_PYTHON=python3.10 \\\n    UV_PROJECT_ENVIRONMENT=/app\n\nCOPY pyproject.toml /_lock/\nCOPY uv.lock /_lock/\n\nRUN --mount=type=cache,target=/root/.cache &lt;&lt;EOT\ncd /_lock\nuv sync \\\n    --frozen \\\n    --no-dev \\\n    --no-install-project\nEOT\n\nFROM python:3.10\n\nCOPY --from=build /app /app\nCOPY . /app\n\nWORKDIR /app\nENV PATH=/app/bin:$PATH\n\nEXPOSE 9000\n\nCMD [\"/app/bin/uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"9000\", \"--reload\", \"--workers\", \"4\"]\n\n\nA note local development with pre-commit\nFor local development, you can use uv with a workflow similar to pipenv or poetry. This has been documented very thoroughly by in the offical uv docs, so I won’t go into too much detail here. If you go through these documentation, you will see that one benefit of using uv most things can be run with either uv run or uvx, which is extremely convenient and makes the Python development exprience closer to that of cargo or npm.\nHowever, at the moment, what I have found is that when making commits with pre-commit, your environment still must be activated:\nsource .venv/bin/activate\nThis is kind of a bummer, but hopefully I might be wrong. Either way, I’m looking forward to seeing how uv develops in the future, particularly with its integration with other tools like pre-commit."
  }
]